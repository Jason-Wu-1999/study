# Redis-12-缓存穿透和雪崩和击穿

**以下都是服务器的高可用问题**

参考博客：https://blog.csdn.net/haoxin963/article/details/83245113

 https://blog.csdn.net/zeb_perfect/article/details/54135506

**面试高频，工作常用**

- **大多数公司目前的数据库查询结构**

![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200416/183833025.png)



## 1. 缓存穿透（查不到）

### 1.1 概念

- 业务系统要查询的数据根本就不存在！当业务系统发起查询时，按照上述流程，首先会前往缓存中查询，由于缓存中不存在，然后再前往数据库中查询。由于该数据压根就不存在，因此数据库也返回空。这就是缓存穿透。
- 综上所述：业务系统访问压根就不存在的数据，就称为缓存穿透。

### 1.2 危害

- 如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃（你要知道，目前**业务系统中最脆弱的就是IO**，稍微来点压力它就会崩溃，所以我们要想种种办法保护它）。

### 1.3 原因

发生缓存穿透的原因有很多，一般为如下两种：

- **恶意攻击，**故意营造大量不存在的数据请求我们的服务，由于缓存中并不存在这些数据，因此海量请求均落在数据库中，从而可能会导致数据库崩溃。
- 代码逻辑错误。这是程序员的锅，没啥好讲的，开发中一定要避免！

### 1.4 解决方案

- 这两种方案都能解决缓存穿透的问题，但使用场景却各不相同。

1. **布隆过滤器（BloomFilter）**

![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200731-171258958.png)

- 它需要在缓存之前再加一道屏障，里面存储目前数据库中存在的所有key，如上图所示
- 当业务系统有查询请求的时候，首先去BloomFilter中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。

### 布隆过滤器原理

目的：就是判断一个数据是否在一个集合中

==bitmap+多个hash函数==

- 存放：将每个值  通过k个hash函数映射到bitmap的k位上
- 判断是否在：==只有k个全部为1 才是在，但凡一个不在就是不在==

![img](https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/imgs/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)

1. **缓存空对象**

- 之所以发生缓存穿透，是因为缓存中没有存储这些空数据的key，导致这些请求全都打到数据库上。
- 那么，我们可以稍微修改一下业务系统的代码，**将数据库查询结果为空的key也存储在缓存中**。当后续又出现该key的查询请求时，缓存直接返回null，而无需查询数据库。
- 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；

![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200416/184512973.png)

但是这种方法会存在两个问题：

1. 第一，**空值做了缓存，意味着缓存层中存了更多的键**，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。
2. 第二，**缓存层和存储层的数据会有一段时间窗口的不一致**，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时**可以利用消息系统或者其他方式清除掉缓存层中的空对象。**

### 1.5 两种方案的比较

- 这两种方案都能解决缓存穿透的问题，但使用场景却各不相同。
- 对于一些恶意攻击，**查询的key往往各不相同，而且数据贼多**。（此时使用**布隆过滤器**比较合适）。（因为它需要存储所有空数据的key，而这些恶意攻击的key往往各不相同，而且同一个key往往只请求一次。因此即使缓存了这些空数据的key，由于不再使用第二次，因此也起不了保护数据库的作用。）
- **key 重复率较高的话，选择缓存空数据比较合适。**

## 2. 缓存击穿（热点数据集中失效）

### 2.1 概念

- 我们一般都会给缓存设定一个失效时间，过了失效时间后，该数据库会被缓存直接删除，从而一定程度上保证数据的实时性。
- 但是，对于一些请求量极高的热点数据而言，一旦过了有效时间，此刻将会有大量请求落在数据库上，从而可能会导致数据库崩溃。其过程如下图所示：

![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200731-172014408.png)

### 2.2 解决方案

**解决方案1：**

- **让缓存永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了。**

“永远不过期”包含两层意思：
从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不过期。
从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存

![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200731-172227270.png)

从实战看，此方法有效杜绝了热点 key 产生的问题，但唯一不足的就是重构缓存期间，会出现数据不一致的情况，这取决于应用方是否容忍这种不一致。

**解决方案2：**

- **互斥锁**

此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可，整个过程如图 :

![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200731-172328772.png)

当第一个数据库查询请求发起后，就将缓存中该数据上锁；此时到达缓存的其他查询请求将无法查询该字段，从而被阻塞等待；当第一个请求完成数据库查询，并将数据更新值缓存后，释放锁；此时其他被阻塞的查询请求将可以直接从缓存中查到该数据。

互斥锁可以避免**某一个**热点数据失效导致数据库崩溃的问题，而在实际业务中，往往会存在一批热点数据同时失效的场景。那么，对于这种场景该如何防止数据库过载呢？



## 3. 缓存雪崩（大量缓存同时失效）

### 3.1 简介

- 如果**缓存因某种原因发生了宕机**，那么原本被缓存抵挡的海量查询请求就会像疯狗一样涌向数据库。此时数据库如果抵挡不了这巨大的压力，它就会崩溃。
- 这就是缓存雪崩。**缓存击穿指并发查同一条数据，缓存雪崩是==不同数据都过期了==，很多数据都查不到从而查数据库。**

![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200416/185246109.png)

### 3.2 解决方案

**（1）redis高可用**

这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活）

**（2）限流降级**

这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

**这里可以使用Hystrix:**

- Hystrix是一款开源的“防雪崩工具”，它通过 **熔断、降级、限流**三个手段来降低雪崩发生后的损失。
- Hystrix就是一个**Java类库，它采用命令模式，每一项服务处理请求都有各自的处理器**。所有的请求都要经过各自的处理器。处理器会记录当前服务的请求失败率。一旦发现当前服务的请求失败率达到预设的值，Hystrix将会拒绝随后该服务的所有请求，直接返回一个预设的结果。这就是所谓的**“熔断”**。
- 当经过一段时间后，Hystrix会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求。这就是所谓的**“限流”**。
- 而Hystrix向那些被拒绝的请求**直接返回一个预设结果**，被称为**“降级”**。

**（3）设置不同的失效时间**

当我们向缓存中存储这些数据的时候，可以将他们的**缓存失效时间错开**。这样能够避免同时失效。如：在一个基础时间上加/减一个随机数，从而将这些缓存的失效时间错开
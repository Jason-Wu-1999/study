

# 1、变量

简短声明要求 **:=** 操作符左边的所有变量==都必须要赋初始值==。

```go
package main

import "fmt"

func main() {  
    name, age := "naveen" //error

    fmt.Println("my name is", name, "age is", age)
}
```

简短声明的语法要求 **:=** 操作符的左边==至少有一个变量是尚未声明的==。     

```go
package main

import "fmt"

func main() {
    a, b := 20, 30 // 声明变量a和b
    fmt.Println("a is", a, "b is", b)
    b, c := 40, 50 // b已经声明，但c尚未声明
    fmt.Println("b is", b, "c is", c)
    b, c = 80, 90 // 给已经声明的变量b和c赋新值
    fmt.Println("changed b is", b, "c is", c)
}
```

# 2、类型

<img src="https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/img/image-20210627222954279.png" alt="image-20210627222954279" style="zoom: 50%;" />



**注意点：**在Go中==string型是不可变的==，但是可以替换

`string`类型虽然是不能更改的，但是可以被替换，因为`stringStruct`中的`str`指针是可以改变的，只是指针指向的内容是不可以改变的。看个例子：

```
func main()  {
 str := "song"
 fmt.Printf("%p\n",[]byte(str))
 str = "asong"
 fmt.Printf("%p\n",[]byte(str))
}
// 运行结果
0xc00001a090
0xc00001a098
```

我们可以看出来，指针指向的位置发生了变化，也就说每一个更改字符串，就需要重新分配一次内存，之前分配的空间会被`gc`回收。

## 2.1**指针**：

-  ==&表示地址		*表示数值==
- ==值类型都有对应的指针类型==；如int对应就是***int**    float对应的就是***float**

## 2.2、自定义类型

```go
type MyInt int 
```

 MyInt是一种==新的类型，但是具有int的特性，但是区别于int==

### 2.3、类型别名

```go
type NewInt=int
```

NewInt还是int类型只是取了别名

==类型别名和自定义类型的区别==

# 3、**命名规则**：

使用驼峰法

go特色:通==过变量、函数名、常量名的首字母是否大写来区别该变量是公有还是私有==

![image-20210628171150967](https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/img/image-20210628171150967.png)

# 4、运算符

### 4.1、自增 ++ --

- 只能当作一个独立的语言使用

```go
 //不能有  
if(i++>0)
var j=i++
```

- 只能放在变量的后面i++，不能放在前面，没有++i

# 5、进制

## 5.1、原码补码反码

1. 最高位是符号位
2. 正数的三个码相同
3. 负数的==反码 = 符号位不变其他位取反==
4. 负数的==补码 = 反码 + 1==
5. 0的反码补码都是0
6. 计算机运算的时候都是用==补码==来进行计算的，**注意：算出来的也是补码，要转换成原码**才是最终答案

<img src="https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/img/image-20210628222326957.png" alt="image-20210628222326957" style="zoom:50%;" />

# 6、流程控制

## 6.1、if else

- if后面直接接 **判断语句不要加括号**
- **一定要有  {	}**，就算只有一条语句也要

## 6.2、for循环

```go
for initialisation; condition; post {  
}
```

三个部分均可以省略

## 6.3、switch

- `case` 不允许出现重复项
- 一个case后面可以接多个表达式，但必须使用“ ==，==”隔开
- 每个case之后==不需要接break==，也会自动跳出来，要想接着执行下一个case需要==使用allthrough语句==来实现
- switch后的表达式可以省略

# 7、数组

- 在go中==数组是值类型==的，而不是引用类型的。也就是说，这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个==副本==。如**果对新变量进行更改，则不会影响原始数组。**
- 数组的长度是固定的，不能改变
- 可以使用for循环的range方式

```go
for i, v := range a {//range returns both the index and value
        fmt.Printf("%d the element of a is %.2f\n", i, v)
        sum += v

```



# 8、切片

- 切片的底层是数组

- 切片是引用类型

- 不能直接==比较两个切片

- append方法为切片添加和删除元素

- 切片需要初始化才能使用==（使用append除外）==

- ==只声明不初始化，值为nil （对于引用类型都是这样）==没有初始化实际上是在内存中并没有真正的存在

- ```
  var arr []int
  fmt.Println(arr)
  fmt.Println(arr==nil)
  ```

输出结果为：

```
[]
true
```



# 9、函数

- ==函数也是一种数据类型==，即函数可以赋值给变量或者**形参**，通过变量来调用这个函数或者作为新的函数的形参

- go函数==不支持重载==

- 支持==可变参数==是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加`...`来标识。

- ```go
  func intSum2(x ...int) int {
  }
  **注意：可变参数通常要作为函数的最后一个参数**。函数的可变参数是通过==切片==来实现的。
  ```

- 支持多返回值

- 函数进阶

  - ==匿名函数==

  - ```go
    func(参数)(返回值){
        函数体
    }
    赋值给变量执行或者作为立即执行函数
    ```

  - ==闭包==：闭包=函数+外层变量的引用

  - **panic/recover**

  1. `recover()`必须搭配`defer`使用。
  2. `defer`一定要在可能引发`panic`的语句之前定义。

# 10、map

- 是引用类型，==必须初始化才能使用==，否则为nil

- 一旦初始化就不为nil，就为对应的0值

- map是无序的

- 不能通过将key值取出判断是否存在，就是不存在也会返回对应0值，应该使用 if ok

  ```GO
  _, ok := x["two"]
  if !ok {
      //不存在
  }
  ```

  

# 11、结构体

- 是值类型

- 在为结构体创建==构造函数==的时候建议返回结构体指针类型

- ```go
  //返回地址，节省性能开销
  func newPerson(name, city string, age int8) *person {
  	return &person{
  		name: name,
  		city: city,
  		age:  age,
  	}
  }
  
  ```

- ==继承==是通过结构体的嵌套来实现的

- 注意如果结构体中的类型是map silce 时，传==入的则是地址，在外面改动会直接影响结构体内部的值。==

# 12、方法和接收者                    

方法与函数的区别是，**==函数不属于任何类型，方法属于特定的类型。==**即方法只能指定类型调用

接收者：值类型，指                  针类型

### 什么时候应该使用指针类型接收者

1. 需要修改接收者中的值
2. 接收者是拷贝代价比较大的大对象
3. 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者

# 13、init函数

- 无参数、无返回值
- 一般用作初始化的工作
- 顺序：全局声明--->init()--->main()
- 若导入的包中又导入了其他的包，则会先追溯执行其他包的init（）
- 不能导入包不使用，不能循环引用包

<img src="https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/img/image-20210714171726465.png" alt="image-20210714171726465" style="zoom: 30%;" />

# 14、接口

- ==接口是一种类型==，一种抽象的类型

- 只要每个变量实现了这个接口，就可以说他是这个接口类型

- **值接收者**：既可以接收值，也可以接收指针

- **指针接收者**只能接收指针

- 空接口的应用场景：
  1. 作为函数的参数
  2. 作为map的值（value）
  
- 类型断言

- 接口实现多态

- ==接口类型变量能够存储所有实现了该接口的实例==

  

# 15、反射

Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的`.Name()`都是返回空

# ·16、goroutine

- 类似线程，用于并发

- 防止main函数执行完了，goroutine还没有执行，需要等待

  1. 最简单的方式time.sleep

  2. 使用`sync.WaitGroup`    Done（）、Add（）、Wait（）

  3. |             方法名              |        功能         |
     | :-----------------------------: | :-----------------: |
     | (wg * WaitGroup) Add(delta int) |    计数器+delta     |
     |     (wg *WaitGroup) Done()      |      计数器-1       |
     |     (wg *WaitGroup) Wait()      | 阻塞直到计数器变为0 |

     ```go
     var wg sync.WaitGroup
     
     func hello(i int) {
     	defer wg.Done() // goroutine结束就登记-1
     	fmt.Println("Hello Goroutine!", i)
     }
     func main() {
     
     	for i := 0; i < 10; i++ {
     		wg.Add(1) // 启动一个goroutine就登记+1
     		go hello(i)
     	}
     	wg.Wait() // 等待所有登记的goroutine都结束
     }
     ```

==Go语言中的操作系统线程和goroutine的关系：==

1. 一个操作系统线程对应用户态多个goroutine。
2. go程序可以同时使用多个操作系统线程。
3. goroutine和OS线程是多对多的关系，即m:n。

# 17、channel

- 是引用类型，需要make 初始化

- 从通道中取值的两种方法

```go
//从通道中取值的方式一
for  {
   tmp,ok :=<-ch1
   if !ok{
      break
   }
   ch2<-tmp*tmp
}


//从通道中取值的方式二
	for ret := range ch2 {
		fmt.Println(ret)
	}
```

- `chan<- int`是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；
- `<-chan int`是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。
- channel只能关闭一次
- 

# 18、进程和线程的区别

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. **一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线**

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多

![img](https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/img/1048430-20170710140043259-1480436304.png)

# 19、并发安全

存在多个`goroutine`同时操作一个资源

==互斥锁==

==读写锁==分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的`goroutine`如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个`goroutine`获取写锁之后，其他的`goroutine`无论是获取读锁还是写锁都会等待。

# 20、网络编程

==TCP==

- 服务端：
  1. 监听端口
  2. 接收客户端请求建立链接
  3. 创建goroutine处理链接。
- 客户端：
  1. 建立与服务端的链接
  2. 进行数据收发
  3. 关闭链接

==UDP==

无需建立连接直接进行数据的传送

# 21、单元测试

测试文件名b'x

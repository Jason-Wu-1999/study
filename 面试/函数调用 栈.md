## 函数调用

> https://blog.csdn.net/weixin_41055260/article/details/123650440

### 进程在内存中的布局

严格意义上是进程在虚拟地址空间的布局.

操作系统把磁盘上可执行文件加载到内存运行之前, 需要做很多工作, 其中很重要的一件事就是**把可执行文件中的代码, 数据存放到内存 中合适的位置, 并分配和初始化程序运行过程中必须的堆栈**, 所有准备工作完成之后操作系统才会调度程序起来运行.

<img src="https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img//imgsimage-20220521173842989.png" alt="image-20220521173842989" style="zoom:50%;" />

进程在内存中布局主要分为4个区域: 代码区, 数据区, heap和stack.

- 代码区, 包括被CPU执行的机器代码(指令)和只读数据比如字符串常亮, 程序一旦加载完成代码区大小就不会再变化了. "代码"就是编 译器编译成机器代码的结果.
- 数据区, 包括程序的全局变量和静态变量(C语言有静态变量, Go没有), 与代码区一样, 程序加载完毕后数据区的大小也不会发生变化.
- heap, 程序运行时动态分配的内存位于 heap 中, 这部分内存由内存分配器负责管理. **该区域的大小会随着程序的运行而变化**. 当我们向 heap 请求分配内存但分配器发现 heap 当中内存不足时, 它会向操作系统内核申请向高地址方向扩展堆的大小, 而当我们释 放内存把它归还给堆时, 如果内存分配器发现剩余空闲内存太对则又会向操作系统请求向低地址方向收缩堆的大小.

### 函数调用栈

函数调用栈简称栈, 在程序运行过程中, 不管是函数执行还是函数调用, 栈都非常关键, 它的主要作用:

- 保存函数的局部变量;
- 向被调用函数传递参数;
- 返回函数的返回值;
- 保存函数的返回地址. **返回地址是指从被调用函数返回后调用者应该继续执行的指令地址**

每个函数在执行过程中都需要使用一块栈内存用来保存上述这些值, 称这块栈内存为函数的栈帧(stack frame). 当发生函数调用时, 因为调用者还没有执行完成, 其栈内存中保存的数据还有用, 所以被调用函数不能覆盖调用者的栈帧, 只能把被调用函数的栈帧"push" 到栈上, 等被调用函数执行完成后再将其栈帧从栈上 "pop" 出去. 这样, 栈大小随着函数调用层级的增加而生长, 随函数的返回而缩 小.

AMD64 CPU 提供了2个与栈相关的寄存器:

- **rsp寄存器, 始终指向函数调用栈栈顶**
- **rbp寄存器, 一般用来指向函数栈帧的开始位置**

函数调用栈以及rsp/rbp与栈之间的关系:

函数调用链: `A()->B()->C()`, 并且正在执行函数 `C()`.

<img src="https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img//imgsimage-20220521173807525.png" alt="image-20220521173807525" style="zoom:50%;" />

说明:

1. ==**调用函数时, 参数和返回值都是存放在调用者的栈帧之中**, 而不是被调用函数之中;==
   1. 参数传递是倒序传入的
2. 当前正在执行C函数, 且函数调用链为 `A()->B()->C()`, 以栈帧为单位的话, C函数的栈帧目前位于栈顶;
3. CPU 硬件寄存器 rsp 指向整个栈的栈顶, 当然它也指向C函数的栈帧的栈顶, 而 rbp 寄存器指向C函数栈帧的起始位置;
4. 有些编译器比如 gcc 会把参数和返回值放在寄存器中而不是栈中, go 语言中函数的参数和返回值都是放在栈上的;

随着程序的运行, 如果 C, B 两个函数都执行完成并返回到A函数继续执行, 则栈的状态如下:

<img src="https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img//imgsimage-20220521173938200.png" alt="image-20220521173938200" style="zoom:50%;" />

由于 C, B 两个函数都已经执行完成并返回到 A 函数之中, 所以 C, B 两个函数的栈帧就已经被 POP 出栈了, 也就是说它们所消耗 的栈内存被自动回收了. 因为现在正在执行的 A 函数, 所以寄存器 rsp, rbp 指向的是 A 函数的栈中相应位置.



**一个函数调用另一个函数通过call调用 ret返回**

## call与ret

###### call指针只做两件事：

- 将下一条指令**入栈**，即**返回地址**，被调用函数执行**结束后可直接跳回这里**继续执行
- 跳转到**被调用函数入口处开始执行**(被调用者是通过栈指针**sp+偏移**找到对应指令进行执行的)

###### ret指令同样做两件事：

- **弹出**返回地址
- **跳转**到返回地址



## 例子

<img src="https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img//imgsimage-20220521174008340.png" alt="image-20220521174008340" style="zoom:50%;" />

一个函数A在a1处调用b1处的函数B，跳转前寄存器和栈的情况如上

### **call :**

- 会把函数A的下一个语句地址a2入栈
- 指令指针寄存器跳转到 函数B的下一个地址,表示下一个语句开始运行函数B

### ret:

- 弹出call指令压栈的返回地址a2
- 指令指针寄存器跳转到这个返回地址 a2





> 后续对本栈帧的内容的访问都是通过帧头（RBP）**==栈帧的基址==**  进行的   向上 `RBP+4 `就是返回地址  向下` RBP - 4` 获取当前函数的局部变量
>
> 调用函数完成之后 通过 leave和ret 会将RBP和RSP 全部 返回到 之前函数的 RBP 和 RSP

![image-20220725185732430](https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img//img/20220725185732.png)
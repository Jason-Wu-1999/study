- java和go的区别：
- 在项目过程中遇到了什么问题
- 怎么防止超卖问题



## 计算机网络：

- http底层协议是什么（ tcp）
- tcp的特点是什么
- http1.0，1.1，2.0的区别
- http和https的区别
- https是用的什么加密方式
  - 对称和非对称加密

## 项目：

- 如何防止超卖

- redis请求用的是list的数据结构  pop之后就从list永久删除了，假如请求处理过程出错，这个list就直接丢弃了，有没有什么挽救办法

- redis集群class       **[redis集群](D:\编程\笔记\Redis\redis集群.md)**

- redis如何设置分布式锁

  - setnx

- 如果用户拿到之后，业务逻辑出现问题，无法释放锁怎么办

  - 设置过期时间  注意保证原子性，要用到lua脚本

- 设置了过期时间，如果业务还没有执行完成，但是redis锁过期了，怎么办？

  - 需要对锁进行续约。
  - 设置锁成功后，启动一个watchdog，每隔一段时间(比如10s)为当前分布式锁续约，也就是每隔10s重新设置当前key的超时时间
  - 如果客户端1加锁成功，这个分布式锁超时时间**默认是30秒**(可以通过Config.lockWatchdogTimeout来修改)。加锁成功后，就会启动一个watchdog，watchdog是一个后台线程，会**每隔10秒**检查一下客户端1是否还持有锁key，如果是，就延长锁key的生存时间，延长操作就是再次把锁key的超时时间设置成30s。
  - ![img](https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/imgs/5aeee6f8904925a8aef8b8ef40de4873.png)

- 前后端的交互，有没有跨域问题

- 其他的队列  ，docker

## Linux：

- 进程，线程，协程之间的区别
- 符号“ | "的作用        **用 管道道进程间通信**
- 进程间的通信方式有哪些    **匿名管道，有名管道，信号量、消息队列、共享内存、套接字Socket、信号** 
- kill是用什么通信方式     **信号**  





## MySQL：

- 事务：特性，隔离级别
- 主从复制  写入主机立马从从机中读    读不到怎么办，主要问处理思路
- 索引 主键怎么设置
- 索引有哪些类型

  - 从物理存储角度：分为聚簇索引和非聚簇索引
  - 从逻辑角度：
    - 主键索引
    - 普通索引/单列索引
    - 复合索引
    - 空间索引
- 聚簇索引和非聚簇索引    MySQL主键属于哪种（聚簇索引）






## 使用三个协程 依次交替打印ABC

使用无缓冲的channel控制 协程工作

```

package main

import (
	"fmt"
	"sync"
)
func main() {
	var ch1, ch2, ch3 = make(chan struct{}), make(chan struct{}), make(chan struct{})
	var wg sync.WaitGroup
	wg.Add(3)
	go func(s string) {
		defer wg.Done()
		for i := 1; i <= 10; i++ {
			<- ch1
			fmt.Print(s)
			ch2 <- struct{}{}
		}
		<- ch1   //从ch1中接收但是忽略结果
	}("A")
	go func(s string) {
		defer wg.Done()
		for i := 1; i <= 10; i++ {
			<- ch2
			fmt.Print(s)
			ch3 <- struct{}{}
		}
	}("B")
	go func(s string) {
		defer wg.Done()
		for i := 1; i <= 10; i++ {
			<- ch3
			fmt.Println(s)
			ch1 <- struct{}{} 
		}
	}("C")
	ch1 <- struct{}{}
	wg.Wait()
}
```





ip是怎么传入的

etcd和mysql怎么保持一致的

gorm操作数据库



# 

## 上海合合信息  面经 3.7号

### 基础

- GPM的调度，p下面有两个G，==什么时候会进行调度==
  - G的调度其实是一种**抢占式的调度**，
  - 当程序启动后，会存在一个sysmon线程（监控线程），属于制定规矩的超级管理者，它会一直存在而且不会受控于GPM规则。当它检查所有的G时，**发现某个G运行时间已经很长了（time=10ms）**,那么sysmon就对该G进行留校察看处分将其标志位置为true,表示该G在下次调用函数时就会被其他的G(已经在队列中等了很久了)抢占，让出对应的M供新的G进行调用
- channel的有缓存和无缓冲的区别
  - 一个同步一个异步
- 读和写已经关闭的chan会怎么样，
  - 可以读，但是写会panic  ，关闭一个已经关闭的
- **==怎么判断channel是否关闭==**
  - 官方推荐使用 **context 和 select** 语法配合使用，事件通知的方式，达到优雅判断 channel 关闭的效果；



讲一下项目

### mysql

- 事务
- 两个搜索引擎
- ==怎么保持原子性和持久性  （redo和undo日志文件）两个日志文件什么时候写的日志文件==
  - u**ndo log**名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。
  - **持久性是利用了redo log**。Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。innodb通过force log at commit机制实现事务的持久性，**即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。也就是说提交了两个日志文件。**
- 什么是聚簇索引和非聚簇索引
  - **聚集索引。**表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。
  - 非聚集索引。表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。
- 讲一下b+树



### 计算机网络

- ==http和https区别==

  - 　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

      　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

          　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    
          　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

- HTTPS的工作原理

  - ##### Https的连接过程？

    1. 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；

    2. 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了**网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息**（证书中的私钥只能用于服务器端进行解密）；

    3. 客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；

    4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；

    5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；

    6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密

       > 总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。
       >
       > ![img](https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/imgs/https%E8%BF%9E%E6%8E%A5)

- ==对称加密和非对称加密的区别

  - **一、密钥不同**
    1、对称加密：对称加密加密和解密使用同一个密钥。
    2、非对称加密：非对称加密加密和解密所使用的不是同一个密钥，需要两个密钥来进行加密和解密。
    **二、安全性不同**
    1、对称加密：对称加密如果用于通过网络传输加密文件，那么不管使用任何方法将密钥告诉对方，都有可能被窃听。
    2、非对称加密：非对称加密因为它包含有两个密钥，且仅有其中的“公钥”是可以被公开的，接收方只需要使用自己已持有的私钥进行解密，这样就可以很好的避免密钥在传输过程中产生的安全问题。
    **三、数字签名不同**
    1、对称加密：对称加密不可以用于数字签名和数字鉴别。
    2、非对称加密：非对称加密可以用于数字签名和数字鉴别。

- DNS系统

  - 

- tcp的==帧结构==

- tcp怎么保证可靠传输

- ==滑动窗口的过程==  发送12345   3丢失会怎么样

  - 接收端会对12返回确认报文  ，并通知新的窗口的大小
  - 滑动窗口会把窗口的最右端移动到3处，等待3超时重传，再对345累计确认



### 数据结构

- 堆的创建过程和==删除过程==
  - 堆是完全二叉树

  **堆的特性：**

  （1）.完全二叉树；

  （2）.每一个节点都大于其左右子节点；

  （3）.根节点最大（大堆）；

  （4）.左子节点2i+1，由子节点2i+2，父节点(i-1)/2；

### 框架

Gin框架的中间件、==路由树底层== 是什么结构（压缩的字典树）

**grpc**、**kafka**







# 二面3.11

## 操作系统：

进程和线程

虚拟内存和物理内存、映射表     虚拟内存为什么比物理内存大

删除文件  修改权限chmod  数字的意思   rwx                chmod u-x的意思

查询进程号，查端口号    文件符





git  提交代码三部

拉取代码并创建新分支，删除新分支



## 数据库

mvcc  

mvcc的隐藏列

select加什么查快照读

b+树

聚簇索引和非聚簇索引



## 计算机网络

http 1.0 、 1.1  2.0的区别



## Go基础

垃圾回收

**什么时候会造成栈溢出**

切片和数组的区别





**海量数据处理算法**

在处理大量数据的时候可以使用bitmap  





# 字节一面

### 你对于限频算法有没有了解 

> 计数器算法

这是最容易理解和实现的算法，假设一个接口1s中最多请求100次。最开始设置一个计数器count=0，来一个请求count+1，1s之内count<=100的请求可以正常访问，count>100的请求则被拒绝，1s之后count被重置为0，重新开始计数

当然这种方式有个弊端，1s内只有最开始的100个请求能正常访问，后面的请求都不能正常访问，即**突刺现象**。**此时我们就可以用滑动窗口算法来解决这个问题，例如把1s分成5个时间段，每个时间段能正常请求20次。**



> 滑动窗口 ：  tcp的流量控制算法

就是计数器算法的改进，将一段时间细分，不仅在大段的时间内进行判断，**在小段时间内也有自己独立的计数器**



> ==漏桶算法==     固定流出速度

漏桶算法参考家里使用的漏斗你就能明白了，往漏斗里面倒水，不论倒多少水，下面出水的速率是恒定的。当漏斗满了，多余的水就被直接丢弃了。

类比流量，每秒处理的速率是恒定的，如果有大量的流量过来就先放到漏斗里面。当漏斗也满了，请求则被丢弃。

**具体实现：用队列保存请求，用ScheduledThreadPoolExecutor（支持定时任务的线程池）来定时从队列中取请求来执行**

**缺点**：不支持突发流量

优点：能够很好的保护别人



> ==令牌桶== （重要）：对漏桶算法的改进     以恒定的速度流入

 令牌桶算法：还是有一个桶，桶里面有N个令牌，所有的请求在处理之前都需要拿到一个可用的令牌才会被处理，如果桶里面没有令牌的话，则拒绝服务；令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌。

==相比漏桶算法，它支持一定的突发==





golang问题：项目结合golang；

讲一下channel的底层实现，

发送和接收队列中存放的是什么？

从channel中拿和写都要加锁吗，不加锁会出现什么问题

多线程和多进程的使用场景；什么时候用进程，什么时候用线程；



浏览器发生那些事情？越详细越好。(计算机网络)



### 访问外网是使用公网ip，服务器处理请求返回之后，怎么知道，是哪个客户端发起的请求，

​	端口映射



TCP和HTTP有什么区别，传输



ETCD的认识？分布式系统，强一致性，最终一致性？



实现分布式定时器？

做题



# 字节二面

1. 介绍实习项目
2. 在纸上画出各个模块的框图
3. 项目中从一个设备下发指令到另一个设备具体是怎么做的
4. 手写定时器，还在提供出他的接口
5. 在局域网内向百度发起请求的具体过程，越详细越好
6. net转换和ARP协议具体是怎么样的
7. 先进行DNS域名解析还是先进行内网到外网的映射（NET）转换
   1. 先进行域名解析
8. 无限制的开goroutine会怎么样
   1. 一个goroutine只占用4k左右的内存，那么在一个 1GB 的 RAM 上，我们就可以有 250 万个 Goroutine 了
9. 逃逸分析 哪些分配在栈，哪些在堆，  各种逃逸具体是什么意思
10. 一个进程在操作系统里面分配哪些空间
11. 





# 腾讯电话一面

### 	项目

1. 自我介绍

2. 自己挑一个项目说

3. 项目有没有上线，或者压测 能顶住多大的用户量 

4. redis作为消息队列会存在什么问题，如何解决

5. 防刷的计数器是怎么实现的     ==可以看看滑动窗口如何实现==

6. 项目中的用户校验是怎么做的，假设自己设计应该如何设计呢

   ### go基础

7. 有没有遇到过goroutine泄露的情况

8. 如何去判断一个未知的项目是否存在  goroutine泄露       使用什么工具 怎么使用、

9. 读和写一个已经关闭的channel会发生什么

10. 如何判断map是否存在某个key，如何删除

11. init函数、全局变量和main函数的执行顺序

12. 把一个变量的指针作为函数的返回值  是否合理，那他是分配在哪里（逃逸分析）

13. 逃逸分析是发送在那个阶段

14. ==go和c文件  是如何进行编译的呢？   四个阶段==

    ### Linux

15. 有一堆文件  找到其中  以`.go`结尾的文件，并返回他们的路径

16. 如何查找进程的uid

17. 监听一个端口，什么状态是端口已经开启监听，什么状态是端口上已经有开服务了，不能再在这个端口开服务了

18. 如何判断一个端口是否能够用来开服务呢    我说通过 主机 `telnet`  IP+端口    还有更好的方法

19. 端口的几种状态分别是什么含义  `listening, closing,time_wait,established`

    ### 网络

20. ping命令发送的是什么类型的数据包   ` ICMP数据包` 答错了 很致命

21. 假设一个ip类型的数据包丢失，怎么判断

22. 

23. 项目中如何实现两个终端发送指令，直接调用接口

24. 自己实现接口会怎么实现

25. 怎么统计这个接口一天或者一周 调用了多少次，，如何实现   很多种方法  随便说一种   使用日志的方式进行统计  还要有具体的实现







## 百度4.16面经

红黑树

go语言csp模型

redis的淘汰策略，在项目中具体使用的什么，如何设置啊



etcd中的节点挂掉了会怎么样，重启失败了呢？

平常有遇到过死锁吗，是怎么去排查死锁的

读过哪些源码，出于什么目的去读的，从中学到了什么（感觉主要讲学到的思路吧）





# 趋势科技

空结构体的使用场景，**为什么空结构体比其他的类型占用空间小**   `不占用空间`

select 中一个chan关闭怎么处理

闭包是什么，存在的意义，**使用场景**

控制最大并发量，如果是可变的怎么实现

map没有初始化直接使用会怎么样

垃圾回收的触发条件

GC之后的内存会立刻返回给OS吗？为什么



项目的白名单 是怎么做的，如何控制来源

库存在内存里面怎么做的持久化呢



提高了系统的性能和可行度  你是用什么指标去衡量的



## 网络

四次挥手的time_wait状态的触发条件，和存在的意义（注意**挥手的发起端**）  ==可以是服务端发起也可以是客户端发起==

学校的主机要想连接家里的主机  （==NET映射）==

ARP协议的过程





# 疯狂游戏

## 二面

1. `+ - * / % `执行的效率比较    
2. 处理哈希冲突的方法，讲一下开放寻址法
3. 拉链法，为什么使用链表不要数组
4. 大量数字hash到同一个key，如何处理
5. **内存对齐和内联函数**对逃逸分析的影响
6. go和java各自的优势

### MySQL

- 执行一条更新语句的具体过程
- 主从复制在**问题1**中的那个阶段
- **问题1**用到的三个日志使用myisam引擎之后还会都有吗

### redis

- redis哪些是多线程的
- 分布式锁加锁和解锁
- **redlock（分布式锁）**

### 场景题：

- 统一用户一年的提交次数，如何设计

答的 使用数据库存对应日期的提交次数

- 追问使用redis缓存MySQL中的提交次数的话，该如何存

答的使用map

- 面试官提示使用bitmap如何统计
  - 一个bitmap占多个位，用来计数

> - bitmap可以统计数据
>   
> - **在2.5亿个整数中找出==不重复==的整数，注，内存不足以容纳这2.5亿个整数。**
>   
>     采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看 bitmap，把对应位是01的整数输出即可。
>   
> - 如果海量数据是不重复的可以利用bitmap排序节省内存

- 找出n个数字中出现最多的数

## 项目

- 项目支持的并发量
- 项目的主要瓶颈在哪里
- redis缓存该如何优化



- 22k * 15  公积金12%， 2k房补、无餐补
- 早10-晚8 
- 6个月试用期   拿60%
- 10点打车报销





# 蔚来提前批1面

自我介绍

项目从技术上怎么优化

输入网址的过程，尽量的详细

MySQL的索引优化



二叉树层序遍历



# 蔚来提前批二面

## 语言

- 为什么选择go语言
- go的CSP模型，GMP模型
- 协程和线程区别

## 操作系统

- 为什么要分用户态和内核态
- 用户态如何进入内核态
- 零拷贝有了解吗，用在哪些地方
- **kafka中的零拷贝是哪个阶段，发布还是消费**

## MySQL

- 索引的数据结构

- 为什么选用b+树

- 讲一下最左匹配原则，abc的联合索引，`where b==1, c==2,a==1` 能不能走索引

- 讲一下回表，count(*) 的原理，会不会回表

- **如何规定一个语句一定走某一个索引    force**      禁止走某个索引  ignore 

  - ```
    select * from table force index(ziduan1_index) limit 2;(强制使用索引"ziduan1_index")
    select * from table ignore index(ziduan1_index) limit 2;(禁止使用索引"ziduan1_index")
    ```

- 三个日志文件 undo log、redo log、binlog

- redo log、binlog两阶段提交

## redis

- redis的过期删除策略和内存删除策略
- 键值删除的时候会对主线程造成什么影响

- **什么时候会触发内存删除策略**

- redis实现分布式锁

- set setex setnx的区别， **Redis的Expire与Setex区别**


## 算法

- 判断是不是平衡二叉树





# 百度提前批一面

## 项目

- 请求之后是不是异步返回
- kafka中假设存在消息堆积，如何快速的异步返回     通过判断队列的长 度和当前库存
- 追问 假设 排在 120位，库存只有100，应该返回失败还是成功
- 如果超时没支付，redis加库存失败怎么办，   用消息重复消费直到成功，保证幂等
- 场景：如果一个请求 要操作redis和MySQL的两张表，怎么保证一致性      使用事务
  - 使用事务的话，先操作什么，再操作什么，什么时候提交

## 语言

多个defer的执行顺序

一个函数return之后如何修改他的值         **使用defer**

## 代码 

- channel控制最大并发数目



# 百度提前批二面

## 项目

- 实习项目，改成MQTT是如何优化

## 计算机网络

- http和https的区别
- https的加密过程
- http的组成
- 了解哪些加密算法和签名算法
- http各个版本的区别

## redis

- redis的数据类型和对于的底层结构
- 什么是分布式锁，这么实现
- expire过期时间如何确定，有没有什么计算公式



## golang

- go的最大优势， GMP模型

- goroutine和异步IO的区别，  不是很理解
- map的底层实现

## 算法

找出两个数组中的交集



# 百度三面（主管面）

- http和https的区别
- https的单向认证和双向认证
- mqtt和tcp的区别
- etcd的raft协议



- 奖学金情况
- 论文情况
- 实习过程学到什么，具体的技术点
- 百度，阿里，腾讯，华为怎么选，理由是什么



# 字节提前批一面

## 项目

- 白名单，如果伪造可不可以检测出来
- 请求放到消息队列之前和之后做了逻辑判断            会判断当前的kafka的队列的长度和当前的库存做判断，判断完之后进行异步的返回
- redis中的key被内存淘汰机制 淘汰掉怎么办   给对应的key设置永不过期，对red is做集群化。让key负载均衡到不同的节点，防止触发内存淘汰机制

- 下单之后对MySQL发生什么事情
- 假设接了对应的 微信或者支付宝的接口，我们后台开发需要考虑哪些问题
  - 保证接口的幂等性
- etcd的在项目中的作用
- 还知道其他的服务注册发现，和etcd

## 计算机网络

- http和https的区别
- https的加密方式
- 对https抓包怎么解密

## 操作系统

- kafka还知道其他的消息队列，各自的区别

- 线程和协程的区别
- 各自使用的场景
  - io密集型   协程
  - cpu密集型 线程

- 哪些行为会发生阻塞   read write

## 手撕

-  合并K个升序链表           对应的时间复杂度和空间复杂度





# 智力题

> 走n个城市，在城市中买一个礼品，在不知道n的情况下，如何保证在每个城市买礼品的概率等概率
>
> https://blog.csdn.net/wq3095435422/article/details/124413184
>
> 不一定是1个 可能是k个 保证每个被选中的概率是  k/n

![image-20220528220030897](https://cdn.jsdelivr.net/gh/Jason-Wu-1999/blog.img/imgs/image-20220528220030897.png)



> 不等概率的硬币，怎么确定出等概率的事件

抛两次  不管怎么不等概率   **抛出一正一反的概率始终相同**

某一次抛出硬币，正面向上的概率是p，反面向上的概率是1 - p
两次均为正面：p * p
第一次正面，第二次反面：p * (1 - p)
第一次反面，第二次正面：(1 - p) * p
两次均为反面：(1 - p) * (1 - p)
中间两种情况的概率是完全一样的。于是问题的解法就是连续抛两次硬币，如果两次得到的相同则重新抛两次；否则根据第一次（或第二次）的正面反面情况，就可以得到两个概率相等的事件。

